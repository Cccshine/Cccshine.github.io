<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="HTML/CSS,BFC,框模型,视觉格式化模型,SPEC,外边距margin," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="今天在了解BFC的相关知识时，看到了视觉格式化模型这个内容，似乎以前没有怎么见过，于是去查了下W3C规范，一查就把自己搞晕了，一下块框，一下块级框，还有块容器框，粗略的看了一遍真是没太理解，于是决定仔细的将它琢磨一下。
首先我们来回顾一下框模型，也就是常说的盒子模型，CSS框模型描述了为文档树中的元素而生成的矩形框。这些框会按照视觉格式化模型来排列显示。典型的框模型如下图所示：">
<meta property="og:type" content="article">
<meta property="og:title" content="框模型与视觉格式化模型">
<meta property="og:url" content="http://Cccshine.github.io/2016/08/04/框模型与视觉格式化模型/index.html">
<meta property="og:site_name" content="Cshine">
<meta property="og:description" content="今天在了解BFC的相关知识时，看到了视觉格式化模型这个内容，似乎以前没有怎么见过，于是去查了下W3C规范，一查就把自己搞晕了，一下块框，一下块级框，还有块容器框，粗略的看了一遍真是没太理解，于是决定仔细的将它琢磨一下。
首先我们来回顾一下框模型，也就是常说的盒子模型，CSS框模型描述了为文档树中的元素而生成的矩形框。这些框会按照视觉格式化模型来排列显示。典型的框模型如下图所示：">
<meta property="og:image" content="http://7xwrfa.com1.z0.glb.clouddn.com/image/3.png">
<meta property="og:image" content="http://7xwrfa.com1.z0.glb.clouddn.com/image/5.png">
<meta property="og:image" content="http://7xwrfa.com1.z0.glb.clouddn.com/image/6.png">
<meta property="og:image" content="http://7xwrfa.com1.z0.glb.clouddn.com/image/7.png">
<meta property="og:image" content="http://7xwrfa.com1.z0.glb.clouddn.com/image/8.png">
<meta property="og:image" content="http://7xwrfa.com1.z0.glb.clouddn.com/image/9.png">
<meta property="og:image" content="http://7xwrfa.com1.z0.glb.clouddn.com/image/10.png">
<meta property="og:image" content="http://7xwrfa.com1.z0.glb.clouddn.com/image/10.png">
<meta property="og:image" content="http://7xwrfa.com1.z0.glb.clouddn.com/image/10.png">
<meta property="og:updated_time" content="2016-08-06T12:38:34.735Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="框模型与视觉格式化模型">
<meta name="twitter:description" content="今天在了解BFC的相关知识时，看到了视觉格式化模型这个内容，似乎以前没有怎么见过，于是去查了下W3C规范，一查就把自己搞晕了，一下块框，一下块级框，还有块容器框，粗略的看了一遍真是没太理解，于是决定仔细的将它琢磨一下。
首先我们来回顾一下框模型，也就是常说的盒子模型，CSS框模型描述了为文档树中的元素而生成的矩形框。这些框会按照视觉格式化模型来排列显示。典型的框模型如下图所示：">
<meta name="twitter:image" content="http://7xwrfa.com1.z0.glb.clouddn.com/image/3.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://Cccshine.github.io/2016/08/04/框模型与视觉格式化模型/"/>

  <title> 框模型与视觉格式化模型 | Cshine </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Cshine</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Full of passion for life</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                框模型与视觉格式化模型
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-04T19:41:15+08:00" content="2016-08-04">
              2016-08-04
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/04/框模型与视觉格式化模型/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/04/框模型与视觉格式化模型/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
          <span>&nbsp; | &nbsp;
          <span id="busuanzi_value_page_pv" ></span>次阅读
          </span>    
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>今天在了解BFC的相关知识时，看到了视觉格式化模型这个内容，似乎以前没有怎么见过，于是去查了下W3C规范，一查就把自己搞晕了，一下块框，一下块级框，还有块容器框，粗略的看了一遍真是没太理解，于是决定仔细的将它琢磨一下。</p>
<p>首先我们来回顾一下框模型，也就是常说的盒子模型，CSS框模型描述了为文档树中的元素而生成的矩形框。这些框会按照视觉格式化模型来排列显示。典型的框模型如下图所示：<br><a id="more"></a><br><img src="http://7xwrfa.com1.z0.glb.clouddn.com/image/3.png" alt=""><br>可以看到有内容框，内边距框，边框框，外边距框四个框组成了框模型，大家应该对此都是比较熟悉的。此处提出几个需要注意的细节</p>
<ul>
<li><code>margin</code>应用于所有元素，但垂直外边距在<strong>非替换行内元素</strong>上不起作用，那么对于<code>img、input</code>之类的替换行内元素自然是起作用的。</li>
<li>对于<code>table</code>系列，<code>margin</code> 只在 <code>table 、caption</code>上有效，对 <code>tr、td、th</code>等等无效。<code>padding</code>只在<code>table,td,th</code>有效。这条规则同样适用于display:table系列</li>
<li><code>margin</code>和<code>padding</code>的百分数取值是相对于包含块的<strong>宽度</strong>,注意均是以宽度为参照。</li>
<li><code>margin</code>允许负值，而且非常强大，具体可参见<a href="https://cccshine.github.io/2016/07/25/%E7%A5%9E%E5%A5%87%E7%9A%84margin%E8%B4%9F%E5%80%BC/">神奇的margin负值</a>,但是<code>padding</code>是不允许负值的。</li>
<li>外边距折叠,既然讲到这里，自己之前也写过相关的笔记，就顺便聊聊好了</li>
</ul>
<h4 id="外边距折叠-collapsed-margin"><a href="#外边距折叠-collapsed-margin" class="headerlink" title="外边距折叠(collapsed margin)"></a>外边距折叠<code>(collapsed margin)</code></h4><p><strong>两个或多个</strong> <strong>相邻</strong>（父子元素或兄弟元素）的块级框<strong>垂直</strong>方向上的 margin 会发生折叠。这种方式形成的外边距即可称为外边距折叠<code>(collapsed margin)</code>，注意加粗的关键字。<br>其中折叠的计算方法为，如果两者的外边距都为正值，则折叠后的外边距值为两者的较大值；如果其中有一个是负值，则折叠后的外边距值为正值减去负值的绝对值得到的值；如果两者都是负值，则折叠后的外边距值为用0减去两者的绝对值中较大的那一个。</p>
<ol>
<li><p><strong>两个或多个</strong><br>单独的一个框是不会发生外边距折叠的，折叠是框与框间相互的行为，不存在 A 和 B 折叠，B 没有和 A 折叠的现象。</p>
</li>
<li><p><strong>相邻</strong>（当且仅当下列情况发生，则称两个外边距相邻）</p>
</li>
</ol>
<ul>
<li>双方都是同一个块格式化上下文（<code>BFC</code>）中属于正常排版的块级框。</li>
<li>没有行框、没有间隙、没有内边距且没有边框隔开它们</li>
<li>双方的框边缘垂直相邻，例如下列一种形式:<ul>
<li>框的上外边距和其属于正常排版的第一个孩子的上外边距(父子关系)<a href="http://7xwrfa.com1.z0.glb.clouddn.com/image/%E5%A4%96%E8%BE%B9%E8%B7%9D%E5%8F%A0%E5%8A%A0.html" target="_blank" rel="external">demo</a></li>
<li>属于正常排版的最后一个孩子的下外边距和其父亲的下外边距，但是只有在其父亲的高度计算值为‘auto’时才发生(父子关系)<a href="http://7xwrfa.com1.z0.glb.clouddn.com/image/%E5%A4%96%E8%BE%B9%E8%B7%9D%E5%8F%A0%E5%8A%A02.html" target="_blank" rel="external">demo</a></li>
<li>框的下外边距和其属于正常排版的下一个兄弟的上外边距(兄弟关系)<a href="http://7xwrfa.com1.z0.glb.clouddn.com/image/%E5%A4%96%E8%BE%B9%E8%B7%9D%E5%8F%A0%E5%8A%A03.html" target="_blank" rel="external">demo</a></li>
<li>框的上、下外边距，如果该框没有建立新的区块格式上下文，且‘min-height’计算值为零、‘height’计算值为零或‘auto’、且没有属于正常排版的孩子(<strong>自身关系</strong>),特别注意这一点<a href="http://7xwrfa.com1.z0.glb.clouddn.com/image/%E5%A4%96%E8%BE%B9%E8%B7%9D%E5%8F%A0%E5%8A%A04.html" target="_blank" rel="external">demo</a></li>
</ul>
</li>
</ul>
<p>通过上面的叙述，其实我们可以从反面着手，就可以找出避免外边距折叠的方法</p>
<ol>
<li>margin 折叠只发生在块级元素上</li>
<li>创建了新块格式化上下文的元素（例如浮动的以及‘overflow’不是‘visible’的元素），不会与其属于正常排版的孩子出现外边距折叠。</li>
<li>有间隙或者内边距<code>padding</code>或者边框<code>border</code>隔开则不会发生外边距折叠</li>
<li>在浮动框和其他框之间的外边距不会折叠（甚至一个浮动框和其属于正常排版的孩子之间也不会出现外边距折叠）。</li>
<li>绝对定位框的外边距不会折叠（和其属于正常排版的孩子也不折叠）。</li>
<li>特殊：根元素的 margin 不与其它任何 margin 发生折叠</li>
</ol>
<h4 id="视觉格式化模型-visual-formatting-model"><a href="#视觉格式化模型-visual-formatting-model" class="headerlink" title="视觉格式化模型(visual formatting model)"></a>视觉格式化模型<code>(visual formatting model)</code></h4><blockquote>
<p>CSS 视觉格式化模型<code>(visual formatting model)</code>是用来处理文档并将它显示在视觉媒体上的机制。视觉格式化模型中，每一个文档树中的元素根据框模型产生零个或多个框。</p>
</blockquote>
<h5 id="包含块Containing-blocks"><a href="#包含块Containing-blocks" class="headerlink" title="包含块Containing blocks"></a>包含块Containing blocks</h5><ul>
<li>一个元素，它的框的尺寸和位置会相对于一个特定的矩形框边缘来计算而得到，这个特定的矩形框称之为该元素的包含块。</li>
<li>一个元素生成的框通常会充当其子框的包含块，我们称它为其子代“创建”（establishes）了包含块。我们平时说的元素的包含块，指的是该元素所处的包含块（比如说absolute元素的包含块指的是body或者最近定位父级），而不是指它自己产生的包含块。</li>
<li>每个框会被给予一个相对于其包含块的位置，但它不会被局限在其包含块内；它有可能会溢出。 </li>
</ul>
<p>包含块的一些创建规则如下：</p>
<ol>
<li>根元素的包含块是一个矩形称作初始包含块,初始包含块的宽度可用由根元素上的width属性指定，若width取值为<code>auto</code>，用户端提供初始宽度（如视口的当前宽度）;初始包含块的高度可用由根元素上的height属性指定，若height取值为<code>auto</code>，包含块的高度将调整以适应文档内容；初始包含块不可以被定位或浮动。</li>
<li>如果元素的<code>position</code>值是<code>relative</code> 或者 <code>static</code>,包含块由最近的块级、单元格<code>table-cell</code>或者行内块<code>inlin-block</code>的祖先框的<strong>内容边界</strong>形成.</li>
<li>如果元素设置了<code>position: fixed</code>，包含块将由连续媒体的视口或分页媒体的页面区域创建.</li>
<li>如果元素设置了<code>position: absolute</code>,包含块由距离最近的，<code>position</code>是<code>absolute</code>, <code>relative</code> 或者 <code>fixed</code>的祖先元素的<code>padding</code>框形成 ,如果没有这样的祖先元素,包含块是初始包含块.</li>
</ol>
<h5 id="块级元素和块框-Block-level-elements-and-block-boxes"><a href="#块级元素和块框-Block-level-elements-and-block-boxes" class="headerlink" title="块级元素和块框 Block-level elements and block boxes"></a>块级元素和块框 <code>Block-level elements and block boxes</code></h5><p><strong>块级元素<code>Block-level elements</code></strong></p>
<ul>
<li>是源文件中会被格式化成块状（例：段落）的元素。</li>
<li><code>display</code>属性的以下取值会让一个元素成为块级元素：<code>block</code>、<code>list-item</code>、<code>table</code>。</li>
<li>块级元素视觉上呈现为块，竖直排列。</li>
</ul>
<p><strong>块元素<code>Block elements</code></strong></p>
<ul>
<li>块元素是 <code>display</code> 属性值为 <code>block</code>的元素，它应该是 块级元素 的一个子集，而不是等同的，一个 块元素 是一个 块级元素，但一个 块级元素 不一定是一个 块元素，所以不要混淆。</li>
</ul>
<p><strong>块级框<code>Block-level box</code></strong></p>
<ul>
<li>是参与块格式化上下文<code>BFC</code>的框。</li>
<li>每个块级元素生成一个主要的块级框来包含其子框和生成的内容，同时任何定位方案都会与这个主要的框有关。</li>
<li>某些块级元素还会在主要框之外产生额外的框：例如<code>list-item</code>元素。这些额外的框会相对于主要框来放置。</li>
<li>块级框用于描述跟它父元素与兄弟元素之间的表现</li>
</ul>
<p><strong><span id="table-cell">块容器框</span><code>Block container box</code></strong></p>
<ul>
<li>除了<code>table</code>框，和可替换元素，一个块级框同时也是一个块容器框。</li>
<li>一个块容器框要么只包含块级框，要么创建一个行格式化上下文<code>IFC</code>而只包含行内级框。</li>
<li>并非所有的块容器框都是块级框，比如说不可替换的行内块<code>(inline-block)</code>和不可替换的<code>table cell</code>是块容器框但不是块级框，我的理解是<code>inline-block</code>和<code>table cell</code>是可以包含块级元素的，但是本身并不是块级元素。所以是块容器框而不是块级框。</li>
<li>块容器框用于描述跟它后代之间的影响</li>
</ul>
<p><strong>块框<code>block box</code></strong></p>
<ul>
<li>是块级框的块容器称作块框</li>
</ul>
<p><strong>匿名块框<code>Anonymous block boxes</code></strong></p>
<ul>
<li><p>块容器框要么只包含行内级框（<code>inline box</code>），要么只包含块级框（<code>block-level box</code>）。但通常情况下会包含两者，这个时候就会创建匿名块框，可以通过下面的例子来理解下</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;DIV&gt;</div><div class="line">  Some text</div><div class="line">  &lt;P&gt;More text</div><div class="line">&lt;/DIV&gt;</div></pre></td></tr></table></figure>
<p>  上面的例子里面，看似既有<code>inline box</code>又有<code>block-level box</code>，实际上会有一个匿名块框围绕在”Some text”周围，这就使得<code>DIV</code>这个块容器框里面只包含块级框。所以如果一个块容器框(如上例中为DIV生成的框)有一个块级框(如上例中的P)，那么我们强制它只包含块级框在其中。</p>
</li>
<li>匿名框不能被选中，因此不能被设置样式，匿名框的继承属性会从包含它的非匿名框那里继承。匿名框的非继承属性将取其初始值。</li>
<li><p>当一个<strong>行内框</strong>包含一个属于<strong>正常排版的块级框</strong>，这个行内框会被块级框（及其连续的块级兄弟）分离成两个框，它在块级框两边。在打断之前和打断之后的行框都附入匿名块框，并且该块级框与匿名块框成为兄弟。当这样的行内框受到相对定位影响，任何产生的移动同样影响到包含在行内框内的块级框。当一个元素导致了匿名块框的生成，则该元素上设置的属性一样能应用于该元素生成的框和其内容之上，举例如下：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">&lt;p&gt;</div><div class="line">	This is anonymous text before the SPAN。</div><div class="line">	&lt;span&gt;This is the content of SPAN.&lt;/span&gt;</div><div class="line">	&lt;span&gt;This is the content of SPAN.&lt;/span&gt;</div><div class="line">	This is anonymous text after the SPAN。</div><div class="line">&lt;/p&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">p&#123;</div><div class="line">	display: inline;</div><div class="line">	border: 1px solid red;</div><div class="line">	background: #fdb;</div><div class="line">	position: relative;</div><div class="line">	top: 50px;</div><div class="line">	left:50px;</div><div class="line">&#125;</div><div class="line">span&#123;</div><div class="line">	display: block;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  p元素<code>display:inline</code>成为行内级元素，span元素<code>display:block</code>成为块级元素，p元素包含一段匿名文本(C1)，随后是块级元素span，再随后是另一段匿名文本(C2)。<br>  对此生成了一个代表body的块框，它包含了围绕C1一个匿名块框、代表span的两个块框，和围绕C2的另一个匿名块框。围绕C1、C2的匿名块框与代表span的块框成为兄弟。<br>  <strong>而此时代表p元素的是什么框呢？</strong>结合前面说过的</p>
<blockquote>
<p>块容器框要么只包含行内级框（<code>inline box</code>），要么只包含块级框（<code>block-level box</code>）。但通常情况下会包含两者，这个时候就会创建匿名块框<br>  如果一个块容器框有一个块级框，那么我们强制它只包含块级框在其中。</p>
</blockquote>
<p>  此时的p元素是一个行内级元素，那么生成的是行内级框，而此时代表body的块级框是一个块容器框，它包含了代表span的块级框，所以我猜想此时代表p元素的是匿名块框。下面有一点也可以证明。<br>  我们回到例子中，上述例子的结果如下所示：<br>  <img src="http://7xwrfa.com1.z0.glb.clouddn.com/image/5.png" alt=""><br>  代表p的行内框设置了相对定位，由于<code>任何产生的移动同样影响到包含在行内框内的块级框</code>，所以span元素也产生了相同的移动;<br>  此时导致匿名块框生成的元素是p元素，我们给p元素加上了边框与背景，由于<code>当一个元素导致了匿名块框的生成，则该元素上设置的属性一样能应用于该元素生成的框和其内容之上</code>，所以边框和背景会显示成图上的形式<br>  <a href="http://7xwrfa.com1.z0.glb.clouddn.com/%E5%8C%BF%E5%90%8D%E5%9D%97%E6%A1%861.html" target="_blank" rel="external">demo</a></p>
</li>
<li>当处理百分比值时，应该忽略匿名块框，而以其最近的非匿名祖先框来替代<br>我们仍以上面的例子为基础，为<code>body</code>添加一个<code>width:800px</code>，为<code>span</code>添加一个<code>padding: 2%</code>,来看看结果会是怎么样<br><img src="http://7xwrfa.com1.z0.glb.clouddn.com/image/6.png" alt="">上图中可以看到<code>span</code>的<code>padding</code>值是16px,这个值也就是<code>800px * 2% = 16px</code>得来的，所以它直接忽略了它的父元素p，而以<code>body</code>替代，因为代表p的是匿名块框（这也证明了上面的猜想）。<br><a href="http://7xwrfa.com1.z0.glb.clouddn.com/%E5%8C%BF%E5%90%8D%E5%9D%97%E6%A1%862.html" target="_blank" rel="external">demo</a></li>
</ul>
<h5 id="行内级元素和行内框-Inline-level-elements-and-inline-boxes"><a href="#行内级元素和行内框-Inline-level-elements-and-inline-boxes" class="headerlink" title="行内级元素和行内框 Inline-level elements and inline boxes"></a>行内级元素和行内框 <code>Inline-level elements and inline boxes</code></h5><p><strong>行内级元素<code>inline-level elements</code></strong></p>
<ul>
<li>是源文档中那些不为其内容形成新的块;而让其内容分布在多行中的元素(如，段落内着重的文本，行内图形等等)。</li>
<li>以下的<code>display</code>属性值产生一个行内级元素:<code>inline</code>, <code>inline-table</code>, and <code>inline-block</code>。</li>
</ul>
<p><strong>行内级框<code>inline-level box</code></strong></p>
<ul>
<li>行内级元素生成行内级框，而这些框会参与某个行内格式化上下文<code>IFC</code>。</li>
<li>行内级框分为行内框和原子行内级框</li>
</ul>
<p><strong>行内框<code>inline box</code></strong></p>
<ul>
<li>内容会参与框本身的行内格式化上下文<code>IFC</code>的行内级框（<code>inline-level box</code>）称为行内框（<code>inline box</code>）</li>
<li>所有<code>display:inline</code>的<strong>非替换元素</strong>生成的框是行内框（<code>inline box</code>）</li>
</ul>
<p><strong>原子行内级框<code>atomic inline-level box</code></strong></p>
<ul>
<li>不是行内框的行内级框(例如可替换的行内级元素、行内块元素、行内表格元素)被称为原子行内级框</li>
<li>它们是以单一不透明框Template:Extra not的形式来参与其行内格式化上下文<code>IFC</code>。</li>
</ul>
<p><strong>匿名行内框<code>Anonymous inline boxes</code></strong></p>
<ul>
<li>任何被直接包含在一个块容器元素（而不是行内元素）中的文本必须视为匿名行内元素</li>
<li><p>这样的行内框从其父块框那里继承可以继承的属性。非继承属性取其初始值，举例如下：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;P&gt;Some &lt;EM&gt;emphasized&lt;/em&gt; text&lt;/P&gt;</div></pre></td></tr></table></figure>
<p>  P元素生成一个块框，其内还有几个行内框。<code>emphasized</code>的框是由行内元素(EM)产生的一个行内框，而其它的框(“Some”和”text”)是块级元素(P)产生的行内框。后者就称为匿名行内框，因为它们没有与之相关的行内级元素。匿名行内框的颜色可以继承自P，而背景是初始的透明的。</p>
</li>
</ul>
<p><strong>行框<code>Line box</code></strong></p>
<ul>
<li>能把在一行上的框都完全包含进去的一个矩形区域，被称为该行的行框。</li>
<li>行框由行内格式化上下文<code>IFC</code>产生，用于表示一行    </li>
<li>更多详情可见<a href="#ifc">IFC</a>的相关部分</li>
</ul>
<h5 id="我们可以自己指定框的类型"><a href="#我们可以自己指定框的类型" class="headerlink" title="我们可以自己指定框的类型"></a>我们可以自己指定框的类型</h5><p>框的类型并不是定死的，没有规定说p元素只能生成块框，比如说上面的一个例子中我们就使他成为了行内框，并由于一些原因最终成为了匿名框，<code>display</code>属性可以用来指定框的类型<br><code>diaplay</code>属性有很多的可取值，下面讲讲他们之间的区别：</p>
<ol>
<li>block<br>这个值让元素产生一个块框。</li>
<li>inline-block<br>这个值让元素产生一个行级块容器。<span id="inlin-block">行内块（inline-block）的内部会被当作块框来格式化，而此元素本身会被当作原子行级框来格式化。</span></li>
<li>inline<br>这个值让元素产生一个或多个的行内框。</li>
<li>list-item<br>这个值让元素（例：HTML 里的 LI）产生一个主块框与标记框。</li>
<li><p>none</p>
<ul>
<li>这个值让元素不出现在排版结构中（也就是在视觉媒体中，元素既不产生框也不影响布局）。</li>
<li>其子孙元素也不产生任何框：该元素及其内容会被从排版结构中完全移除。对子孙元素设定 <code>display</code> 属性不能覆盖这个结果。</li>
<li>请注意display属性取值为 <code>none</code> 并不会产生隐形的框：<code>none</code> 完全不产生任何框。这是不同于<code>visbility</code>属性的。</li>
</ul>
</li>
<li><p>table、inline-table、table-row-group、table-column、table-column-group、table-header-group、table-footer-group、table-row、table-cell 与 table-caption<br>这些值让元素产生表格元素的行为</p>
</li>
</ol>
<h5 id="再来看看定位方案-Positioning-schemes"><a href="#再来看看定位方案-Positioning-schemes" class="headerlink" title="再来看看定位方案`Positioning schemes"></a>再来看看定位方案<code>`Positioning schemes</code></h5><p>CSS 2.1 中，会根据三种定位方案来摆放框：</p>
<ul>
<li>正常排版<code>Normal flow</code>。CSS 2.1 中，正常排版包括对块级框的块格式化，对行级框的行格式化，对块级框和行级框的相对定位。</li>
<li>浮动<code>Float</code>。在浮动模型中，一个框先按照正常排版来摆放，再将它从排版流中取出并尽可能地向左或向右偏移。其它内容可以排在一个浮动的周围。</li>
<li>绝对定位<code>Absolute positioning</code>。在绝对定位模型中，一个框会从排版流中完全脱离出来（它对后续的兄弟没有影响），并相对其包含块来指定其位置。</li>
</ul>
<h6 id="正常排版Normal-flow"><a href="#正常排版Normal-flow" class="headerlink" title="正常排版Normal flow"></a>正常排版Normal flow</h6><p>框在正常排版中必然属于一个格式化上下文<code>formatting contxet</code>，要么是块格式化上下文<code>Block formatting contxet</code> ，要么是行格式化上下文<code>Inline formatting context</code>。块级框参与块格式化上下文。行级框参与行格式化上下文。<br><strong>块格式化上下文<code>BFC</code></strong></p>
<ul>
<li>BFC其实就是块级框的布局规则，相当于CSS页面布局的地基，并非什么神奇的概念，大家习以为常的一些东西其实最终的解释是可以归于BFC的。</li>
<li>创建了BFC的元素规定了内部的块级框如何布局，并且使该框在页面上形成一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然</li>
<li>在BFC中，框会从包含块的顶部开始，一个接一个地，垂直向下地摆放<br><code>我们常说block元素很霸道，会扩展到与父元素同宽，block元素会垂直排列，其实是因为BFC的约束。</code></li>
<li>两个兄弟框之间的垂直距离由<code>margin</code>属性来决定。在同一个BFC中，相邻的块级框之间的垂直外边距会出现折叠。<br><code>常见的外边距折叠，其实并不是bug，而是由于BFC的约束。</code></li>
<li>在BFC中，每个框的左外边距边要紧贴其包含块的左边(对于从左往右的格式化)，否则相反。即使在有浮动的情景下也是如此，除非框创建了一个新的BFC(在这种情况下该框可能会为了避开浮动框而变窄)。</li>
<li>BFC的区域不会与float box重叠（<a href="https://cccshine.github.io/2016/08/04/%E7%90%86%E8%A7%A3CSS%E4%B8%AD%E7%9A%84BFC/#more">利用这个特性可以做自适应窗口大小</a>）</li>
<li>计算BFC的高度时，浮动元素也参与计算（<a href="https://cccshine.github.io/2016/08/04/%E7%90%86%E8%A7%A3CSS%E4%B8%AD%E7%9A%84BFC/#more">清除浮动的原理</a>）<br><code>大家肯定知道overflow:hidden可以清浮动，哈哈，就是因为这个啦</code></li>
<li>下列情况将创建一个BFC：<ul>
<li>根元素</li>
<li>浮动 (元素的 float 不为 none)</li>
<li>绝对定位元素 (元素的 position 为 absolute 或 fixed)</li>
<li>行内块 inline-blocks (元素的 display: inline-block)<br><code>注意：虽然display:inline-block的元素本身被当做一个原子行级框来格式化，但其内部会被当作块框来格式化，所以它是可以创建BFC的，而它本身是参与IFC的。</code><a href="#inlin-block">你可以回到上面看看相关内容</a></li>
<li>表格单元格 (元素的 display: table-cell，HTML表格单元格默认属性)<br><code>注意：虽然display: table-cell的元素本身不能生成块级框，但是可以包含块框，所以可以创建BFC。</code><a href="#table-cell">你可以回到上面看看相关内容</a></li>
<li>表格标题 (元素的 display: table-caption, HTML表格标题默认属性)</li>
<li>overflow 的值不为 visible的元素</li>
<li>弹性盒子 flex boxes (元素的 display: flex 或 inline-flex)</li>
</ul>
</li>
<li>BFC的相关应用可以见另一篇文章<a href="https://cccshine.github.io/2016/08/04/%E7%90%86%E8%A7%A3CSS%E4%B8%AD%E7%9A%84BFC/#more">BFC的应用</a></li>
</ul>
<p><strong><span id="ifc">行格式化上下文<code>IFC</code></span></strong></p>
<ul>
<li>IFC其实就是行级框的布局规则，也不是很么神奇的概念。</li>
<li>在IFC中，框会从包含块的顶部开始，一个接一个地水平摆放。<br><code>这也就解释了inline元素与inline-block元素为啥是排在一排了</code></li>
<li>摆放这些框的时候，它们在水平方向上的外边距、边框、内边距所占用的空间都会被考虑在内。</li>
<li>在垂直方向上，这些框可能会以不同形式来对齐：它们可能会把底部或顶部对齐，也可能把其内部的文本基线对齐。</li>
<li>以下情况会创建一个IFC：<ul>
<li>块容器框（block container box）中<strong>只有</strong>行内元素时会建立IFC</li>
<li>匿名行内框（anonymouse inline boxes）中会建立IFC</li>
</ul>
</li>
<li><span id="line-box">能把在一行上的框都完全包含进去的一个矩形区域，被称为该行的行框</span>。</li>
<li>行框的宽度是由包含块和存在的浮动来决定的。一般来说行宽的宽度就是包含块的宽度，行框的高度计算方法见<a href="#line-height">行框高度计算</a>。</li>
<li>行框一定会高到足以容纳它所包含的全部框。但它也可能比它所包含的最高框还要高（比如这些框是由基线对齐）</li>
<li>当一个框的高度小于包含它的行框的高度，它在行框中垂直的位置由vertical-align属性来决定</li>
<li>当几个行内级框在水平方向上无法塞进同一个行框时，他们会分布在两个或多个垂直堆放的行框中。行框会以既没有垂直间距也没有重叠的方式堆叠起来。</li>
<li>当一个行内框的宽度超过了行框的宽度，则它会被分割成几个框，而这些框会分布在几个行框。如果此行内框不可分割（例如：单个字符、或语言指定的文字打断规则不允许在此行内框中出现打断、或该行内框受white-space属性为nowrap或pre的影响），那么该行内框溢出该行框。</li>
<li>行内框被分割的时候，外边距、边框和内边距不会应用在出现分割的地方。</li>
<li>通常，行框的左边紧贴其包含块的左边，而行框的右边紧贴其包含块的右边。然而，浮动框可以插在包含块边缘与行框边缘之间。因此，尽管在同一个IFC中的行框通常有同样的宽度（也就是其包含块的宽度），但它们的宽度也可能受浮动让水平可用空间减少的影响而有所改变。</li>
<li>在同一个IFC中，行框的高度通常是变化的（例如：某一行包含了一个比较高的图片，而其它行只包含文本）。</li>
<li>当一行上的行级框的总宽度小于包含它们的行框的宽度，则它们在行框内的水平分布由’text-align’属性来决定。</li>
<li>行框如果满足以下条件，会以零高度来对待<ul>
<li>不包含文本或保留空格</li>
<li>不包含内外边距或边框宽度非零的行内元素</li>
<li>不包含其它正常排版的内容（images、inline-block、inline-table）</li>
<li>不以保留的换行符结尾</li>
</ul>
</li>
<li><strong><span id="line-height">行框的高度的计算</span></strong><ul>
<li>行框里各行内级框的高度，对于替换元素、行内块元素、行内表格元素来说，高度边界高度：对于行内框来说，这是由line-height决定。</li>
<li>行框的高度是由该行框里面的最高的行内级框的高度决定的，而不是仅仅由最高的line-height决定。比如说，这个行框里面的文字的最高的line-height是20px,而这个行框里面有一个图片，它的高度是40px,那么这个行框的高度将是40px。</li>
</ul>
</li>
</ul>
<p>下面来一个实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;p&gt;</div><div class="line">	Several &lt;em&gt;emphasized words&lt;/em&gt; appear</div><div class="line">	&lt;strong&gt;in this&lt;/strong&gt; sentence, dear.</div><div class="line">&lt;/p&gt;</div></pre></td></tr></table></figure></p>
<p>P元素产生一个块框，它包含了五个行内框，其中的三个是匿名的。<br>为了格式化这一段，用户代理（通常为浏览器）将这五个框排入行框内。本例中，为P元素生成的框形成了行内框的包含块。如果该包含块足够宽，则这所有的行内框将放在一个行框内。如下所示<br><img src="http://7xwrfa.com1.z0.glb.clouddn.com/image/7.png" alt=""><br>否则，行内框将被分割并分布在几个行框之内,如下所示<br><img src="http://7xwrfa.com1.z0.glb.clouddn.com/image/8.png" alt=""><br>当存在行内框不可分割不可分割的情况时，会溢出，如下所示<br><img src="http://7xwrfa.com1.z0.glb.clouddn.com/image/9.png" alt=""></p>
<h6 id="浮动Float"><a href="#浮动Float" class="headerlink" title="浮动Float"></a>浮动Float</h6><ul>
<li>在当前行向左或右偏移的框就是浮动框。</li>
<li>浮动框最有趣的特点是其它内容可以紧挨着它的一侧来排版 (也可以通过’clear’属性来禁止这样排版)。内容会紧挨着左浮框的右侧排版，而紧挨着右浮框的左侧排版。</li>
<li>一个浮动框会向左或向右进行偏移直到其外边缘紧贴其包含块的边缘或另一个浮动框的外边缘。</li>
<li>如果摆放浮动框时，当前行已有一个行框，则浮动框的顶部外边缘会与该行框的顶部对齐。</li>
<li>如果因当前行剩余水平空间不足而放不下一个浮动框，则该浮动框会下移，直到找到放得下它的位置或者当前位置以下已没有更多浮动出现。</li>
<li>因为浮动不属于正常排版流(Normal flow)，在浮动框前面和后面被创建的<strong>非定位块框</strong>会如同该浮动不存在一样地垂直排版。但是，当前和随后的紧挨着浮动框被创建的<strong>行框</strong>，会按需要缩短其宽度来为浮动框的外边距框让出空间。<br>这也就解释了为什么block元素会在浮动元素下面，而block元素中的inline元素会围绕着浮动元素但是不会被浮动元素盖住。</li>
<li>如果被缩短后的行框过小，以至于它无法容纳任何内容，则应使该行框下移（并重新计算其可用宽度），直到它能容纳一些内容，或其下方已无其它浮动框。当前行中位于浮动框前面的任何内容要在浮动的另一边重新排版。左浮动就在其右边重新排版，右浮动就在其左边重新排版。</li>
</ul>
<h5 id="绝对定位-Absolute-positioning"><a href="#绝对定位-Absolute-positioning" class="headerlink" title="绝对定位 Absolute positioning"></a>绝对定位 Absolute positioning</h5><ul>
<li>在绝对定位模型中，一个框基于它的包含块而显式地偏移。它完全从正常排版中脱离(对后继的兄弟没有影响)。</li>
<li>一个绝对定位框为它的正常排版子元素和绝对定位(不是fixed)后代生成一个新的包含块。</li>
<li>绝对定位元素的内容不会在其它框的周围排列。它们可能会也可能不会挡住另外一个框的内容(或者被挡住)，这取决于互相重合的框的堆叠层次。</li>
<li>固定定位是绝对定位的一个子类。唯一的区别是，对于固定定位框，它的包含块由视口创建。</li>
</ul>
<h5 id="display、position-与-float-的关系"><a href="#display、position-与-float-的关系" class="headerlink" title="display、position 与 float 的关系"></a><code>display</code>、<code>position</code> 与 <code>float</code> 的关系</h5><ul>
<li>如果<code>display</code>值为<code>none</code>，元素不生成框，那么<code>position</code>和<code>float</code>无效。</li>
<li>否则，如果<code>position</code>值为<code>absolute</code>或者<code>fixed</code>，那么此时<code>float</code>计算的值为<code>none</code>，也就是说并不会产生浮动，并且 display根据下面的表格进行设定。框的位置由<code>top</code>, <code>right</code>, <code>bottom</code>和<code>left</code>属性和<strong>包含块</strong>决定。<br><code>所以如果inline元素的</code>position<code>值为</code>absolute<code>或者</code>fixed<code>，它就可以设置宽高了，因为display的计算值变为block了</code><br><img src="http://7xwrfa.com1.z0.glb.clouddn.com/image/10.png" alt=""></li>
<li>否则，如果<code>float</code>的值不是<code>none</code>，该框是浮动的，且<code>display</code>值根据下面的表格进行设定。<br><code>所以如果inline元素设置了float，它就可以设置宽高了，因为display的计算值变为block了</code><br><img src="http://7xwrfa.com1.z0.glb.clouddn.com/image/10.png" alt=""></li>
<li>否则，如果元素是根元素，<code>display</code>值根据下面的表格进行设定，除了其在CSS2.1里面没有定义是否指定值<code>list-item</code>对应计算值<code>block</code>或者<code>list-item</code><br><img src="http://7xwrfa.com1.z0.glb.clouddn.com/image/10.png" alt=""></li>
<li>否则，<code>display</code> 的计算值为指定的值。<br><code>注意：此处的否则代表依次否定上一条，也就是说最后一条是排除了前面的所有条件的情况下。</code></li>
</ul>
<h5 id="分层的呈现-Layered-presentation"><a href="#分层的呈现-Layered-presentation" class="headerlink" title="分层的呈现 Layered presentation"></a>分层的呈现 Layered presentation</h5><p>主要是z-index属性，详见<a href="https://cccshine.github.io/2016/08/03/z-index%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/#more">我想更了解z-index</a></p>
<h5 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h5><p>写了这么多，虽然大部分是W3C规范里的内容，但是整个慢慢的看下来，自己也收获不小，文章里有一些自己的理解，因为经验尚且，可能会有错误，还请大家多多指教。里面有一些知识时穿插着的，所以建议先顺着看一遍理解一下，对于不懂的先放着，可能下文就有讲述，看完第一遍之后再看一遍以加深理解与印象。</p>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><ul>
<li><a href="https://www.w3.org/html/ig/zh/wiki/CSS2/box#mpb-examples" target="_blank" rel="external">W3C/CSS2/box</a></li>
<li><a href="https://www.w3.org/html/ig/zh/wiki/CSS2/visuren#direction" target="_blank" rel="external">W3/CCSS2/visuren</a></li>
<li><a href="http://blog.leanote.com/post/codert/%E8%A7%86%E8%A7%89%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A8%A1%E5%9E%8B-2" target="_blank" rel="external">视觉格式化模型</a></li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/HTML-CSS/" rel="tag">#HTML/CSS</a>
          
            <a href="/tags/BFC/" rel="tag">#BFC</a>
          
            <a href="/tags/框模型/" rel="tag">#框模型</a>
          
            <a href="/tags/视觉格式化模型/" rel="tag">#视觉格式化模型</a>
          
            <a href="/tags/SPEC/" rel="tag">#SPEC</a>
          
            <a href="/tags/外边距margin/" rel="tag">#外边距margin</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/08/04/理解CSS中的BFC/" rel="next" title="BFC的应用">
                <i class="fa fa-chevron-left"></i> BFC的应用
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/09/07/仿天猫首页的总结/" rel="prev" title="仿天猫首页的总结">
                仿天猫首页的总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2016/08/04/框模型与视觉格式化模型/"
     data-title="框模型与视觉格式化模型"
     data-content=""
     data-url="http://Cccshine.github.io/2016/08/04/框模型与视觉格式化模型/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/08/04/框模型与视觉格式化模型/"
           data-title="框模型与视觉格式化模型" data-url="http://Cccshine.github.io/2016/08/04/框模型与视觉格式化模型/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/icon.jpg"
               alt="Cshine" />
          <p class="site-author-name" itemprop="name">Cshine</p>
          <p class="site-description motion-element" itemprop="description">Full of passion for life</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">9</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#外边距折叠-collapsed-margin"><span class="nav-number">1.</span> <span class="nav-text">外边距折叠(collapsed margin)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#视觉格式化模型-visual-formatting-model"><span class="nav-number">2.</span> <span class="nav-text">视觉格式化模型(visual formatting model)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#包含块Containing-blocks"><span class="nav-number">2.1.</span> <span class="nav-text">包含块Containing blocks</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#块级元素和块框-Block-level-elements-and-block-boxes"><span class="nav-number">2.2.</span> <span class="nav-text">块级元素和块框 Block-level elements and block boxes</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#行内级元素和行内框-Inline-level-elements-and-inline-boxes"><span class="nav-number">2.3.</span> <span class="nav-text">行内级元素和行内框 Inline-level elements and inline boxes</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#我们可以自己指定框的类型"><span class="nav-number">2.4.</span> <span class="nav-text">我们可以自己指定框的类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#再来看看定位方案-Positioning-schemes"><span class="nav-number">2.5.</span> <span class="nav-text">再来看看定位方案`Positioning schemes</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#正常排版Normal-flow"><span class="nav-number">2.5.1.</span> <span class="nav-text">正常排版Normal flow</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#浮动Float"><span class="nav-number">2.5.2.</span> <span class="nav-text">浮动Float</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#绝对定位-Absolute-positioning"><span class="nav-number">2.6.</span> <span class="nav-text">绝对定位 Absolute positioning</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#display、position-与-float-的关系"><span class="nav-number">2.7.</span> <span class="nav-text">display、position 与 float 的关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#分层的呈现-Layered-presentation"><span class="nav-number">2.8.</span> <span class="nav-text">分层的呈现 Layered presentation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#结束语"><span class="nav-number">2.9.</span> <span class="nav-text">结束语</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#参考资料"><span class="nav-number">2.10.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cshine</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<br>本站总访问量 <span id="busuanzi_value_site_pv"></span> &nbsp&nbsp&nbsp
您是第<span id="busuanzi_value_site_uv"></span>个来到的小伙伴

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cccshine"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
